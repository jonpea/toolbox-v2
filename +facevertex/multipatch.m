function varargout = multipatch(varargin)

import arguments.parsefirst
import contracts.unreachable
import datatypes.isaxes
import structs.merge

[ax, labels, table, varargin] = parsefirst(@isaxes, gca, 2, varargin{:});

% Support both tables and structs
switch class(table)
    case 'table'
        numRows = height(table);
        columnNames = table.Properties.VariableNames;
        tableRow = @(index) table2struct(table(index, :));
    case 'struct'
        numRows = structs.tabular.height(table);
        columnNames = fieldnames(table);
        tableRow = @(index) structs.tabular.rows(table, index);
    otherwise
        assert(false, unreachable)
end

parser = inputParser;
parser.KeepUnmatched = true;
parser.addParameter('Faces', [], @ismatrix)
parser.addParameter('Vertices', [], @ismatrix)
parser.addParameter('XData', [], @ismatrix)
parser.addParameter('YData', [], @ismatrix)
parser.addParameter('ZData', [], @ismatrix)

parser.parse(varargin{:});

    function result = isspecified(varargin)
        result = all(~ismember(varargin, parser.UsingDefaults));
    end
isfacevertex = isspecified('Faces', 'Vertices');
ispolygon2d = isspecified('XData', 'YData');
ispolygon3d = ispolygon2d && isspecified('ZData');
ispolygon = ispolygon2d || ispolygon3d;

assert(xor(isfacevertex, ispolygon), ...
    'Insufficient data for face-vertex or polygon respresentation')

if ispolygon
    error([mfilename, ':PolygonsUnsupported'], ...
        'Polygon representations are not yet supported')
end

scene = parser.Results;
if numel(labels) ~= size(scene.Faces, 1)
    error([mfilename, ':SceneLabelMismatch'], ...
        'Array of labels should have one element for each face')
end

sharedsettings = setfield( ...
    parser.Unmatched, ...
    'Vertices', scene.Vertices); %#ok<SFLD>

% "Reference field" is the first of any field names not recognized
% as patch properties (see "Patch Properties" in MATLAB documentation)
[candidates, indices] = setdiff(columnNames, patchfieldnames);
if isempty(candidates)
    error([mfilename, ':NoRefField'], ...
        'No candidate reference fields exist')
end
% NB: "candidates{1}" would not preserve original ordering
keyname = candidates{indices(1)};

if ~isa(table.(keyname), class(labels))
    error([mfilename, ':LabelTypeMismatch'], ...
        'Types of labels and reference field do not match')
end

if iscellstr(labels)
    equals = @strcmp;
elseif isnumeric(labels)
    equals = @eq;
else
    error([mfilename, ':UnsupportedLabels'], ...
        'Face labels be numeric or a cell array of character vectors')
end

for row = numRows : -1 : 1
    rowsettings = structfun( ...
        @uncellstr, ...
        tableRow(row), ...
        'UniformOutput', false);
    label = rowsettings.(keyname);
    rowsettings = rmfield(rowsettings, candidates);
    rowsettings.Faces = scene.Faces(equals(labels, label), :);
    handles(row) = patch(ax, merge(rowsettings, sharedsettings));
end

if 0 < nargout
    varargout = {handles};
end

end

function c = uncellstr(c)
if iscellstr(c)
    assert(isscalar(c))
    c = c{:};
end
end

function names = patchfieldnames
% This list is generated by:
% >> fieldnames(get(patch))
% We don't actually employ this command here as generates new axes.
names = {
    'CData'
    'CDataMapping'
    'FaceVertexCData'
    'EdgeColor'
    'FaceColor'
    'Faces'
    'LineStyle'
    'LineWidth'
    'VertexNormals'
    'VertexNormalsMode'
    'FaceNormals'
    'FaceNormalsMode'
    'AmbientStrength'
    'DiffuseStrength'
    'SpecularStrength'
    'SpecularExponent'
    'SpecularColorReflectance'
    'Marker'
    'MarkerEdgeColor'
    'MarkerFaceColor'
    'MarkerSize'
    'Vertices'
    'Clipping'
    'AlignVertexCenters'
    'AlphaDataMapping'
    'FaceVertexAlphaData'
    'EdgeAlpha'
    'FaceAlpha'
    'XData'
    'YData'
    'ZData'
    'FaceLighting'
    'EdgeLighting'
    'BackFaceLighting'
    'UIContextMenu'
    'ButtonDownFcn'
    'BusyAction'
    'BeingDeleted'
    'Interruptible'
    'CreateFcn'
    'DeleteFcn'
    'Type'
    'Tag'
    'UserData'
    'Selected'
    'SelectionHighlight'
    'HitTest'
    'PickableParts'
    'DisplayName'
    'Annotation'
    'Children'
    'Parent'
    'Visible'
    'HandleVisibility'
    };
end
