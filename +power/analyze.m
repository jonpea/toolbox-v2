function [dlinks, ulinks, interactions] = analyze(origins, targets, varargin)

[traceoptions, unmatched] = tracesceneargumentsnew(varargin{:});

parser = inputParser;
parser.addParameter( ...
    'AccessPointChannel', ...
    ones(size(origins, 1), 1), ...
    @(c) isvector(c) && isround(c) && 1 <= min(c) && numel(c) == size(origins, 1))
parser.addParameter( ...
    'MinimumDiscernableSignal', ...
    minimumdiscernablesignal, ... % [dBW]
    @(x) isscalar(x) && x < 0)
parser.parse(unmatched)
linkoptions = parser.Results;

compareversions = true;
if compareversions
    % Gain components (in watts) for each reflection arity
    ttemp = tic; %#ok<UNRCH>
    [downlinkgainswatts2, uplinkgainswatts2, interactions2] = ...
        tracescenenew(origins, targets, traceoptions);
    toc(ttemp)
end
% ===>>>
fprintf('\n')
fprintf('####### Re-running with tracescene2... #######\n')
ttemp = tic;
[downlinkgainswatts, uplinkgainswatts, interactions, durations] = ...
    tracescenenew2(origins, targets, traceoptions); %#ok<ASGLU>
totalelapsed = toc(ttemp);
fprintf('Elapsed time is %.5f seconds.\n', totalelapsed)
if compareversions
    compare(downlinkgainswatts, downlinkgainswatts2)
    compare(uplinkgainswatts, uplinkgainswatts2)
    save analyzedata interactions interactions2
    structsfun(@compare, [interactions.Data, interactions2.Data])
    assert(all(structsfun(@isequal, [interactions.Functions, interactions2.Functions])))
    labindices = (1 : numworkers)';
    durations = vertcat(durations{:}); % transfer from workers to client
    minduration = min(durations);
    maxduration = max(durations);
    disp('Statistics:')
    tabulardisp(struct( ...
        'LabIdx', labindices(:), ...
        'Duration', durations, ...
        'DurationRelToMax', durations / maxduration))
    fprintf('    Min DurationRelToMax: %f\n', minduration/maxduration)
    fprintf('Communication overhead: 1.0 - %.2f/%.2f = %.2f%%\n', ...
        maxduration, totalelapsed, (1.0 - maxduration/totalelapsed)*100)
    fprintf('####### ... matched tracescene v1. #######\n')
end
% <<<===

% Received gain (in dBW): Rows for access points, columns for mobiles
downlinkgaindbw = todb(sum(downlinkgainswatts, 3));

% Downlink calculations
dlinks = dlinksinr( ...
    downlinkgaindbw, ...
    linkoptions.AccessPointChannel, ...
    linkoptions.MinimumDiscernableSignal);
dlinks.PowerComponentsWatts = downlinkgainswatts;
dlinks.PowerDBW = downlinkgaindbw;

dlinks = orderfields(dlinks, {
    'PowerDBW' ...
    'PowerComponentsWatts' ...
    'SINRatio' ...
    'INGainDBW' ...
    'SGainDBW' ...
    'AccessPoint' ...
    'Channel' ...
    });

if nargout < 2
    return
end

% Received gain (in watts), rows for receivers
uplinkgainwatts = sum(uplinkgainswatts, 3);
uplinkgaindbw = todb(uplinkgainwatts);

% Uplink calculations
ulinks = ulinksinr( ...
    uplinkgaindbw, ...
    dlinks.AccessPoint, ...
    linkoptions.AccessPointChannel, ...
    linkoptions.MinimumDiscernableSignal);
ulinks.PowerComponentsWatts = uplinkgainswatts;
ulinks.PowerDBW = uplinkgaindbw;

ulinks = orderfields(ulinks, {
    'PowerDBW' ...
    'PowerComponentsWatts' ...
    'SINRatio' ...
    'INGainDBW' ...
    'SGainDBW' ...
    });
