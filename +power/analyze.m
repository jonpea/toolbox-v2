function [dlinks, ulinks, interactions] = analyze(origins, targets, varargin)

[traceoptions, unmatched] = imagemethod.tracesceneargumentsnew(varargin{:});

parser = inputParser;
parser.addParameter( ...
    'AccessPointChannel', ...
    ones(size(origins, 1), 1), ...
    @(c) isvector(c) && isround(c) && 1 <= min(c) && numel(c) == size(origins, 1))
parser.addParameter( ...
    'MinimumDiscernableSignal', ...
    minimumdiscernablesignal, ... % [dBW]
    @(x) isscalar(x) && x < 0)
parser.parse(unmatched)
linkoptions = parser.Results;

[downlinkgainswatts, uplinkgainswatts, interactions, durations] = ...
    imagemethod.tracescenenew2(origins, targets, traceoptions); %#ok<ASGLU>

% Received gain (in dBW): Rows for access points, columns for mobiles
downlinkgaindbw = elfun.todb(sum(downlinkgainswatts, 3));

% Downlink calculations
dlinks = power.dlinksinr( ...
    downlinkgaindbw, ...
    linkoptions.AccessPointChannel, ...
    linkoptions.MinimumDiscernableSignal);
dlinks.PowerComponentsWatts = downlinkgainswatts;
dlinks.PowerDBW = downlinkgaindbw;

dlinks = orderfields(dlinks, {
    'PowerDBW' ...
    'PowerComponentsWatts' ...
    'SINRatio' ...
    'INGainDBW' ...
    'SGainDBW' ...
    'AccessPoint' ...
    'Channel' ...
    });

if nargout < 2
    return % uplink calculations are not required
end

% Received gain (in watts), rows for receivers
uplinkgainwatts = sum(uplinkgainswatts, 3);
uplinkgaindbw = elfun.todb(uplinkgainwatts);

% Uplink calculations
ulinks = power.ulinksinr( ...
    uplinkgaindbw, ...
    dlinks.AccessPoint, ...
    linkoptions.AccessPointChannel, ...
    linkoptions.MinimumDiscernableSignal);
ulinks.PowerComponentsWatts = uplinkgainswatts;
ulinks.PowerDBW = uplinkgaindbw;

ulinks = orderfields(ulinks, {
    'PowerDBW' ...
    'PowerComponentsWatts' ...
    'SINRatio' ...
    'INGainDBW' ...
    'SGainDBW' ...
    });
